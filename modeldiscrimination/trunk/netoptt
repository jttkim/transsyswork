#!/usr/bin/python

import getopt
import sys
import os
import transsys
import transsys.optim 
from math import sqrt
import trsysmodis


def write_result(f, optResult) :
 f.write('// objective: %g\n' % optResult.objectiveOptimum.fitness)
 f.write('%s\n' %  str(optResult.optimised_transsys_program))
 f.flush()


def rw_operation() :
  sequence = []
  for i in range(0,20) :
    n = int(round(1.2**i))
    if n not in sequence:
      sequence.append(n)
  return sequence


num_restarts = None
equilibration_length = None
name_network = None
target_expr_data = None
target_pheno_data = None
target_feature_data = None
gradient = 'optspec'
f_distance = None
verbose = 1
transformerfile = 'transformerfile'
rulefile = 'rulefile'
logfile = None
finalparam = None

optlist, args = getopt.getopt(sys.argv[1:], 'r:e:n:s:t:N:E:b:x:p:f:g:T:u:R:v:lvh')

for opt, par in optlist :
  if opt == '-h' :
    print '-r  <int>: specify number of random restarts'
    print '-e  <int>: specify time steps for equilibration'
    print '-n  <int>: specify number of networks'
    print '-s  <int>: specify number of reshuffles'
    print '-t  <int>: specify name of the network'
    print '-N  <int>: specify number of nodes'
    print '-E  <int>: specify number of edges'
    print '-x  <str>: specify gene expression profile file name'
    print '-p  <str>: specify pheno data file name'
    print '-f  <str>: specify feature data file name'
    print '-g  <str>: specify gradient file name'
    print '-R  <str>: specify rule file name'
    print '-T  <transformer specfile>: specify transformer specification file to parse'
    print '-u  <str>: 1: sum_squares, 2: correlation, 3: euclidean'
    print '-V  <int>: Verbose'
    print '-h: print this help and exit'
    sys.exit()
  elif opt == '-r' :
    num_restarts = int(par)
  elif opt == '-e' :
    equilibration_length = int(par)
  elif opt == '-n' :
    rw_repeticion = int(par)
  elif opt == '-s' :
    reshuffles = int(par)
  elif opt == '-t' :
    name_network = par
  elif opt == '-N' :
    node = int(par)
  elif opt == '-E' :
    edge = int(par)
  elif opt == '-x' :
    target_expr_data = par
  elif opt == '-p' :
    target_pheno_data = par
  elif opt == '-f' :
    target_feature_data = par
  elif opt == '-g' :
    gradient = par
  elif opt == '-T' :
    transformerfile = par
  elif opt == '-R' :
    rulefile = par
  elif opt == '-u' :
    f_distance = par
  elif opt == '-v' :
    verbose = int(par)
  else :
    raise StandardError, 'unhandled option "%s"' % opt


if len(args) > 0 :   
  logfile = open(args[0], 'w')
if len(args) > 1 :   
  finalparam = open(args[1], 'w')

logo = file('%slogo.txt'%name_network,'w')


g = open(gradient, 'r')
optimiser = transsys.optim.parse_optimiser(g)
g.close

if transformerfile is not None :
  g = open(transformerfile, 'r')
  optimiser.transformer = transsys.optim.parse_parameter_transformer(g)
g.close()

if rulefile is not None :
  g = open(rulefile, 'r')

optimiser.verbose = verbose

logo.write('rw_operation\trw_repetition\tfitness\n')
index = 0

x = open('%s'%target_expr_data, 'r')
p = open('%s'%target_pheno_data, 'r')
f = open('%s'%target_feature_data, 'r')
expression_set = trsysmodis.ExpressionSet()
expression_set.read(x, p, f)
rule = trsysmodis.parse_rule(g)
print rule
for i in rule:
  print i.factor_name
objective_function = trsysmodis.KnockoutTreatmentObjective(expression_set, equilibration_length, rule)

if f_distance == 'sum_squares' :
  objective_function.distance_function = trsysmodis.distance_sum_squares
elif f_distance == 'correlation' :
  objective_function.distance_function = trsysmodis.distance_correl
elif f_distance == 'euclidean' :
  objective_function.distance_function = trsysmodis.distance_euclidean
else :
  raise StandardError, 'unknown distance %d' % f_distance

objective_function.distance_measu = expression_set.divergence


optimiser.randomInitRange = 1.0
model = open('%s.tra'%(name_network),'r')
transsys_program = transsys.TranssysProgramParser(model).parse()
print "preliminar",objective_function(transsys_program)
for restart_index in xrange(num_restarts) :
  opt_result = optimiser.optimise(transsys_program, objective_function)
  sys.stderr.write('%s\n' % str(objective_function(opt_result.optimised_transsys_program)))
  if finalparam is not None :
    write_result(finalparam, opt_result)
  if logfile is not None :
    opt_result.write_log(logfile, 'tp_index')


\documentclass[a4paper,fleqn]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage[english]{babel}
\usepackage{alltt}

\newcommand{\computercode}[1]{\texttt{#1}}
\newcommand{\newterm}[1]{\emph{#1}}
\newcommand{\todo}[1]{\rule{0pt}{0pt}\marginpar{\rule{1ex}{1ex}}\textbf{\emph{[#1]}}}
\newcommand{\otherlang}[1]{\textit{#1}}

\newenvironment{ebnfrule}{\begin{footnotesize}\begin{quote}\begin{alltt}}{\end{alltt}\end{quote}\end{footnotesize}}

\textwidth16cm
\leftmargin0cm
\rightmargin0cm
\oddsidemargin0cm
\evensidemargin0cm

\parindent0pt
\parskip 1ex plus 0.5ex minus 0.2ex


\begin{document}

\title{Technical Report: \\
  Modelling Experimental Procedures Using Transsys}
\author{Anyela Camargo, Jan T.\ Kim}
\maketitle

\section{Introduction}

\newterm{Gene expression measurements} are measurements that determine
the amount of product of one or more genes in a biological sample. The
amount or concentration of a gene product is called the
\newterm{expression level} of the gene that encodes the product.

Samples for gene expression measurement are typically cultivated at
controlled conditions. While the exact conditions depend on the object
of research and the specific research question, the properties that
are subject to control can generally be classified into genetic
properties and environmental conditions.

The set of expression levels of a given gene, measured in different
samples, is called the \newterm{expression profile} (or profile, for
short) of that gene. The set of expression levels of all genes in all
samples is called an \newterm{expression set}, or, in recognition of
the ``genes $\times$ conditions'' format of the set, an
\newterm{expression matrix}.

\newterm{Genetic properties} pertain to the genetic makeup of the
subjects.  Specifically, genes may be \newterm{knocked out} (loss of
function mutations), or they may be \newterm{overexpressed} (gain of
function mutations).

There is a wide range of \newterm{environmental conditions} that
biological subjects may be exposed to. A frequent condition is
treatment with some agent, such as a hormone, drug, or other effector.

Gene expression levels that have been measured are subjected to
various mathematical operations. It is common practice to work in the
\newterm{logarithmic domain} (i.e.\ to take the logarithm of the raw
expression levels), because up- and down-regulation can be directly
compared with such ``logarithmised'' values. Gene expression
measurement can sometimes produce negative values as an artifact. This
must be addressed before values are transformed to the logarithmic
domain. Adding a small offset is a simple remedy of this problem.

Once gene expression levels are adequately conditioned, expression
profiles can be compared. Quantitatively, comparison takes place by
defining a \newterm{distance measure} that quantifies how dissimilar
two profiles are. Two straightforward distance measures are the
Euclidean distance and the correlation distance (which is a
semi-metric distance), defined as $1 - r(g_1, g_2)$, where $r(g_1,
g_2)$ denotes correlation coefficient between the expression profiles
of genes $g_1$ and $g_2$.

The sum of distances of expression profiles is a distance between two
expression sets.

The transsys framework \cite{Kim2001,transsyshome} provides a basis for simulating regulatory
networks with different genetic properties, and for deriving loss or
gain of function variants of a given regulatory network by removing or
adding genes, respectively. Different environmental conditions can be
simulated by designating factors that are subject to external
alteration, and using different settings of the the expression levels
of these factors to simulate different conditions.

The language defined here is designed to enable succinct and flexible
specification of such biological processes and experimental procedures
\otherlang{in silico} that result in a simulated expression matrix,
and also to specify a distance measure to compare the simulated matrix
to an \newterm{target matrix} comprised of expression data that is
externally provided (i.e.\ not generated by way of simulation). The
target matrix is also called the \newterm{empirical matrix}. In
addition to this specification, a transsys program, called the
\newterm{candidate program}, that models the regulatory network is
required to carry out the simulation. Candidate programs must satisfy
certain criteria in order to be suitable for simulation according to a
specification. Specifically, the transsys program needs to have
factors and genes that are specified by name in the simulation
protocol specification. Within these requirements, candidate programs
can be freely chosen.

\todo{we should not use synonyms and decide on whether to use
  expression set / expression matrix, target matrix / empirical
  matrix, \ldots}


\section{Objective Function Specification}

\subsection{Language Structure}

Syntactic features:

\begin{itemize}
\item Blocks should be in curly braces rather than in
  \computercode{something} \ldots \computercode{endsomething}.
\item Statements should be delimited by \computercode{;} so that
  newlines are not necessary or considered as terminators or
  separators.
\item \computercode{simexpression} blocks are really procedures, so
  they are replaced with procedures.
\item review keywords
\end{itemize}

\subsubsection{The Top Level}

\begin{ebnfrule}
objectivespec ::= SimGenex
\end{ebnfrule}
The \computercode{SimGenex} is a string that
identifies the file as an objective function specification. The
\computercode{SimGenex} states the
objective function specification.

\begin{ebnfrule}
simgenex_def ::= procedure_defs simexpression_defs measurementmatrix_def 
discriminationsettings_def \end{ebnfrule}

The core of a SimGenex program describes how to use a transsys GRN
model to produce a simulated gene expression matrix from the  
definition of a set \computercode{simexpressions} of primary operations
that are sufficiently general to simulate most standard experimental 
\computercode{procedures}. The \computercode{measurementmatrix} 
block describes how to transform the primary simulated matrix into a 
\newterm{measurement matrix} by e.g.\ computing log-ratios. Finally, the 
\computercode{discriminationsettings} block configures computation of the 
distance of the measurement matrix to a target matrix.

\subsubsection{Procedures}
\label{section_procedures}

\begin{ebnfrule}
procedure_defs ::= (procedure_def)*
procedure_def ::= procedure_header procedure_body

procedure_header ::= "procedure" identifier
procedure_body ::= "\{" (procedure_statement)* "\}"

procedure_statement ::= instruction ";"

instruction ::= identifier
        | primary_instruction

primary_instruction ::= knockout_instruction
        | runtimesteps_instruction
        | treatment_instruction
        | overexpress_instruction
        | setproduct_instruction
        | foreach_instruction

knockout_instruction ::= "knockout:" identifier 

runtimesteps_instruction ::= "runtimesteps" integer 

treatment_instruction ::= "treatment" identifier "=" realnumber 

overexpress_instruction ::= "overexpress" identifier "=" realnumber 

setproduct_instruction ::= "setproduct" identifier identifier 

\end{ebnfrule}
A procedure specifies a sequence of operations to be performed on a
transsys instance. Operations are specified either by primary
instructions or by other procedures. Primary instructions specify
elementary operations that the simulator knows to perform. These are:
\begin{itemize}
\item \computercode{runtimesteps} runs the specified number of time
  steps to create a new transsys instance.
\item \computercode{knockout} removes the specified gene from the
  transsys program. The identifier must be the name of a gene in the
  candidate program. \todo{is it possible to ``knock a gene back
    in''?}. The knockout affects gene expression simulation (via the
  \computercode{runtimesteps} instruction) issued subsequently to the
  \computercode{knockout} instruction. Notice that the
  \computercode{knockout} operation modifies the candidate program.
\item \computercode{treatment} takes the name of a factor and a value
  that the expression level of the factor is to be set to. This
  operation is applied to the current transsys instance, overwriting
  the previous expression level of the factor. Subsequently, the
  expression dynamics of the factor will be determined by the
  candidate program.
\item \computercode{overexpress} inserts a new gene into the candidate
  program. The identifier is the name of an existing gene in the
  candidate program. The new gene encodes the same product as the
  specified existing gene, and has a promoter comprised of one
  \computercode{constitutive} element, expressing the gene at the
  specified rate.
\item \computercode{setproduct} replaces the product of the gene
  identified by the first identifier with the factor identified by the
  second identifier.
\item \computercode{foreach} expects a list of procedures. A
  \computercode{simexpression} containing a \computercode{foreach}
  statement results in multiple expression simulations. Each simulation
  is defined by the body of the \computercode{simexpression} element
  with the \computercode{foreach} statement replaced by the call to
  one of the procedures in the list. If a \computercode{simexpression}
  element contains multiple \computercode{foreach} statements, this
  replacement is carried out recursively so that all possible
  combinations of procedure calls are generated.
\end{itemize}
An identifier in a procedure body identifies another procedure to be
invoked. Invoking another procedure results in execution of the
instruction in the other procedure's body. By recursively applying
this rule, a procedure ultimately reduces to a sequence of primary
instructions.  It is an error for a procedure to refer to itself, or
to any procedure that eventually invokes itself, as infinite recursion
would occur in this case. \todo{is this ensured and is there a unit
  test for this?}

It is an error if an identifier does not reference an existing
procedure. Procedures may be listed in any order, so it is legal to
reference a procedure before it is defined.


\subsubsection{Gene Expression Sample Simulation}

\begin{ebnfrule}
simexpression_defs ::= (simexpression_def)*
simexpression_def ::= simexpression_header simexpression_body

simexpression_header ::= "simexpression" identifier 
simexpression_body ::= "\{" (simexpression_statement)* "\}"

simexpression_statement ::= simexpression_instruction ";"

simexpression_instruction ::= instruction
        | foreach_instruction

foreach_instruction ::= "foreach" (identifier)+

\end{ebnfrule}

\todo{is there a reason to only allow procedures in the simexpression
  body? I think that simexpressions should also be allowed to contain
  primary instructions. This would mean that the bodies of procedures
  and simexpressions are specified in the same way (i.e.\ by the same
  rule). This would also make sense from an object oriented angle, as
  indeed a simexpression \emph{is a} (subclass of a) procedure, with
  the added feature that it results in the simulation of a column in
  the empirical matrix.}

\todo{On further pursuing this line of thought, it seems to me that
  the introduction of arrays has, from a formal / minimalist
  perspective, made simexpressions obsolete: Arrays could also be
  expressed in terms of procedures. It may however be worthwhile from
  the semantic perspective of distinguishing between procedures as
  partial instruction sequences that are to be used as building
  blocks, and simexpressions as complete sequences that model the life
  of a biological object.}

Simulations of gene expression, or ``simexpressions'' for short,
describe a simulation procedure to produce a transsys instance. The
idea is that the simulation procedure models the genetic makeup and
the relevant conditions and (possibly) experimental manipulations
experienced by a biological object. If the candidate program is a good
model of the gene regulatory network in the biological object, the
expression levels in the transsys instance are expected to be similar
to those measured in the biological object.

Like procedures, simexpressions may be composed of primary instructions 
and procedure invocations. In addition, they also may contain 
\computercode{foreach} instructions. Such simexpressions define multiple 
columns in the simulated matrix. The \computercode{foreach} instruction 
enables very compact specifications of setups in which a number of strains are
subjected to the same set of experimental conditions. For example, the
declaration

\begin{alltt}
simexpression s
\{
  foreach: wildtype komutant;
  equilibration;
  foreach mock real;
  onehour;
\}
\end{alltt}
specifies four columns in which the genotypes \computercode{wildtype}
and \computercode{komutant} are subjected to \computercode{mock} and
the \computercode{real} treatment. each. \computercode{wildtype}. The
procedures \computercode{komutant}, \computercode{mock} and
\computercode{real} have to be defined in order for the above code
fragment to work.

The sequence of identifiers in the body of a simexpression is resolved
to a sequence of primary instructions, as described for procedures in
section \ref{section_procedures}. The sequence of primary operations
is applied to a transsys instance of the unmodified candidate program,
with all expression levels starting at $0$. (Note: Future extensions
may provide mechanisms for specifying the initial state of the instance.)

Identifiers in a simexpression body must identify procedures. 
Invocation of other simexpressions is an error.


\subsubsection{Computing the Simulated Matrix}

\begin{ebnfrule}
measurementmatrix_def ::= "measurementmatrix" "\{" measurementprocess_def 
measurementcolums_def genemapping"\}"
\end{ebnfrule}

As in the wet lab scenario, the columns of a matrix simulated by
SimGenex need to be transformed following the same protocols that were
applied to compute the target matrix of empirical data. SimGenex
uses the following blocks within the
\computercode{measurementmatrix} section to specify such procedures:

\begin{itemize}
\item\computercode {measurementprocess}: specifies how individual gene
  expression values are normalised. \computercode{offset} how
  expression values are transformed to simulate a column in a gene
  expression matrix \computercode{transformation}

\begin{ebnfrule}

measurementprocess_def ::= "measurementprocess" "\{" offset_def transformation_def "\}"
offset_def ::= "offset:" realnumber ";"
        | "offset:" realnumber * expressionstat ";"
expressionstat ::= "negmin()" | "stddev()"
transformation ::= "transformation:" transformation_expr ";"
transformation_expr ::= transformation_term "+" transformation_expr
        | transformation_term "-" transformation_expr
        | transformation_term
transformation_term ::= transformation_unary "*" transformation_term
        | transformation_unary "*" transformation_term
        | transformation_unary
transformation_unary ::= "log2(" transformation_expression ")"
        | "offset(" transformation_expr ")"
        | "(" transformation_expr ")"
        | identifier

\end{ebnfrule}

\item \computercode{measurementcolumns}: specifies the columns in the
  simulated expression matrix. Columns are computed by subjecting the
  expression levels in one or more simexpressions to mathematical
  operations, resulting in a column containing one value for each
  mapped factor of the candidate program. The idea is that the
  mathematical operations should be the same as those applied to the
  raw empirical data that have resulted in the empirical expression
  matrix.

\begin{ebnfrule}
measurementcolumns_def ::=  "measurementcolumns" "\{" 
measurementcolumn_statement* "\}"
measurementcolumn_statement ::= identifier ":" mvar_assignment_list ";"
mvar_assignment_list ::= mvar_assignment_list "," mvar_assignment
        | mvar_assignment
mvar_assignment ::= identifier "=" identifier
\end{ebnfrule}

\begin{ebnfrule}
genemapping_def ::= "\{" totalproduct_statement* "\}" 
totalproduct_statement ::= totalproduct_expr ":" gene_manufacturer_identifier ";"
totalproduct_expr ::= totalproduct_term "+" totalproduct_expr
        | totalproduct_term
totalproduct_term ::= totalproduct_unary "*" totalproduct_term
        | totalproduct_unary
totalproduct_unary ::= "(" totalproduct_expression ")"
        | identifier

\end{ebnfrule}

\item \computercode{genemapping}: specifies names of genes in the computational 
model that can be mapped only to names in the target matrix, which may e.g.\ be IDs 
designated by the microarray provider. It also specifies what gene's
combination makes up for its total RNA to simulate a row in the gene expression matrix. 

The identifiers of the left hand side must be names of factors in the
candidate program. No factor can be mapped more than once.
\end{itemize}



\subsubsection{Discrimination Settings}

\begin{ebnfrule}
  discriminationsettings_def ::= "discriminationdettings" 
  "\{"  distance_def whitelist_def "\}"
\end{ebnfrule}

\begin{ebnfrule}
distancemeasure_def ::= "distance:" distance_type 
distance_type ::= "correlation" | "euclidean" | "sum_squares" 
\end{ebnfrule}

SimGenex allows the specification of a \computercode{distance} measure
to compare the simulated matrix to a target matrix which can e.g.\ be
used to discriminate the best GRN model from among a number of
candidates. In addition, as in the real scenario, SimGenex allows the
specification of a mapping scheme.


\begin{ebnfrule}
whitelist_def ::= whitelist_header whitelist_body whitelist_footer

whitelist_header ::= "whitelistdefs" 
whitelist_body ::= whitelist_factor_def whitelist_gene_def
whitelist_footer ::= "endwhitelistdefs" 
whitelist_factor_def ::= "factor" ":" (identifier)+
whitelist_gene_def ::= "gene: " (identifier)+ 
\end{ebnfrule}

%Beyond configuring matrix distance, the \computercode{discriminationsettings} 
%section may provide further
%configuration to be used in the process of discriminating GRN models.

\computercode{whitelist} specifies which factors or genes a discriminator may adjust. 
This feature is useful where parts of the GRN model are unknown, and the discriminator should
therefore explore various alternatives for the unknown parts. As an
example, where numerical parameters are unknown, these can be set by
numerical optimisation.

WhiteList terms are those factors or genes, in a transsys program, whose
initial conditions must not be changed by the optimiser when performing
model selection. There are a number of reasons why this option is available, 
one of them is the use of mathematical expressions rather than single values
to specify under which conditions a biochemical reaction might take place.

\subsection{Terminal Tokens (Lexical Structure)}

\begin{ebnfrule}
----- terminals --------------------------------------------------------------------

SimGenex_magic ::= "SimGenex-0.1" 


gene_manufacturer_identifier ::= doublequote character_but_not_doublequote+ doublequote

realnumber ::= digit_sequence "." unsigned_digit_sequence+ scale_factor+
                | digit_sequence scale_factor

digit_sequence ::= sign+ unsigned_digit_sequence

unsigned_digit_sequence ::= digit+


scale_factor ::= ("E" | "e") digit_sequence
sign ::=  "+" | "-"


digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

identifier ::= (letter | "_") (letter | digit | "_")+

letter ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K"| "L" 
| "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W"| "X" | "Y" 
| "Z"| "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k"| "l" 
| "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

doublequote ::= the doublequote character (chr(34))
\end{ebnfrule}
\bibliographystyle{plain}
\bibliography{bioinfo}


\section{Future Perspectives}

\subsection{Optimisation by Reusing Prefix Instruction Sequences}

Simexpressions reduce to sequences of primary instructions. If two
simexpressions share a prefix (i.e.\ they start with the same sequence
of instructions) and the candidate program is deterministic (i.e.\ it
does not use any of the random number generation functions provided by
transsys), the two simexpressions that share a prefix sequence can be
computed by first computing the prefix sequence and then using that as
a starting point for computing both the first and the second
simexpression. Depending on the execution time of the prefix, this can
be a significant optimisation (e.g.\ where many time steps are used
for equilibration of a transsys instance).

As a special case, one simexpression may be a prefix of another.
When a set of simexpressions simulates a time series, they will form
nested prefixes.

To fully exploit the optimisation potential especially for time series
as described above, an optimiser must be able to break up a
\computercode{runtimesteps} $t$ instruction into commands
\computercode{runtimesteps} $n_1$ and \computercode{runtimesteps}
$n_2$, where $n_1 + n_2 = n$, as appropriate.

It is important to notice that the validity of this optimisation
depends on the assumption that the candidate program is
deterministic. This may not hold, therefore simulating all
simexpressions independently must be retained.

If the transsys program object provided a method to detect whether
the program is deterministic, simulators could use that method to
automatically activate the prefix optimisation as appropriate.


\section{Example SimGenex 2.0 Code}

\begin{footnotesize}
\begin{verbatim}
SimGenex-2.0


procedure equilibration
{
  runtimesteps: 300;
}

procedure timepoint015min
{
  runtimesteps: 3;
}

procedure timepoint030min
{
  runtimesteps: 6;
}

procedure ko_g0
{
  knockout: g0;
}

procedure f1_treatment
{
  treatment: f1 = 1.0;
}

procedure overexpressgene
{
  overexpress: g1 = 0.7;
}

simexpression wt
{
  equilibration;
}

simexpression wt_treatment15
{
  equilibration;
  f01_treatment;
  timepoint015min;
}

simexpression wt_treatment30
{
  equilibration;
  f01_treatment;
  timepoint030min;
}

simexpression g0
{
  ko_g0;
  equilibration;
}

simexpression g0_treatment15
{
  ko_g0;
  overexpressgene;
  equilibration;
  f01_treatment;
  timepoint015min;
}

simexpression g0_treatment30
{
  ko_g0;
  equilibration;
  f01_treatment;
  timepoint030min;
}

measurementmatrix
{

  measurementprocess
  {
    # offset: 1 * negmin();
    offset: 1e-3 * stddev();
    transformation: log(offset(x1)) / log(offset(x2));
  }

  measurementcolumns
  {
    wt_treatment15 : x1 = wt_treatment15, x2 = wt;
    wt_treatment30 : x1 = wt_treatment30, x2 = wt;
    g0000_treatment15 : x1 = g0_treatment15, x2 = g0;
    g0000_treatment30 : x1 = g0_treatment30, x2 = g0;
    # idea for later consideration -- not yet in language spec
    # wt : transformation log(wt) / log(wt);
  }

  genemapping
  {
    factor f0 = "257221_at" "257222_at" "257223_at";
    factor f1 = "257224_at";
  }
}

discriminationsettings
{
  distance: correlation;
  whitelistdefs
  {
    factor: f0 f1
    gene: g0
  }
}
\end{verbatim}
\end{footnotesize}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

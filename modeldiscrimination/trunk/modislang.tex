\documentclass[a4paper,fleqn]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage[english]{babel}
\usepackage{alltt}

\newcommand{\computercode}[1]{\texttt{#1}}
\newcommand{\newterm}[1]{\emph{#1}}
\newcommand{\todo}[1]{\rule{0pt}{0pt}\marginpar{\rule{1ex}{1ex}}\textbf{\emph{[#1]}}}
\newcommand{\otherlang}[1]{\textit{#1}}

\newenvironment{ebnfrule}{\begin{footnotesize}\begin{quote}\begin{alltt}}{\end{alltt}\end{quote}\end{footnotesize}}

\textwidth16cm
\leftmargin0cm
\rightmargin0cm
\oddsidemargin0cm
\evensidemargin0cm

\parindent0pt
\parskip 1ex plus 0.5ex minus 0.2ex


\begin{document}

\title{Technical Report: \\
  Modelling Experimental Procedures Using Transsys}
\author{Anyela \ Camargo, Jan T.\ Kim}
\maketitle

\section{Introduction}

\newterm{Gene expression measurements} are measurements that determine
the amount of product of one or more genes in a biological sample. The
amount or concentration of a gene product is called the
\newterm{expression level} of the gene that encodes the product.

Samples for gene expression measurement are typically cultivated at
controlled conditions. While the exact conditions depend on the object
of research and the specific research question, the properties that
are subject to control can generally be classified into genetic
properties and environmental conditions.

The set of expression levels of a given gene, measured in different
samples, is called the \newterm{expression profile} (or profile, for
short) of that gene. The set of expression levels of all genes in all
samples is called an \newterm{expression set}, or, in recognition of
the ``genes $\times$ conditions'' format of the set, an
\newterm{expression matrix}.

\newterm{Genetic properties} pertain to the genetic makeup of the
subjects.  Specifically, genes may be \newterm{knocked out} (loss of
function mutations), or they may be \newterm{overexpressed} (gain of
function mutations).

There is a wide range of \newterm{environmental conditions} that
biological subjects may be exposed to. A frequent condition is
treatment with some agent, such as a hormone, drug, or other effector.

Gene expression levels that have been measured are subjected to
various mathematical operations. It is common practice to work in the
\newterm{logarithmic domain} (i.e.\ to take the logarithm of the raw
expression levels), because up- and down-regulation can be directly
compared with such ``logarithmised'' values. Gene expression
measurement can sometimes produce negative values as an artifact. This
must be addressed before values are transformed to the logarithmic
domain. Adding a small offset is a simple remedy of this problem.

Once gene expression levels are adequately conditioned, expression
profiles can be compared. Quantitatively, comparison takes place by
defining a \newterm{distance measure} that quantifies how dissimilar
two profiles are. Two straightforward distance measures are the
Euclidean distance and the correlation distance (which is a
semi-metric distance), defined as $1 - r(g_1, g_2)$, where $r(g_1,
g_2)$ denotes correlation coefficient between the expression profiles
of genes $g_1$ and $g_2$.

The sum of distances of expression profiles is a distance between two
expression sets.

The transsys framework provides a basis for simulating regulatory
networks with different genetic properties, and for deriving loss or
gain of function variants of a given regulatory network by removing or
adding genes, respectively. Different environmental conditions can be
simulated by designating factors that are subject to external
alteration, and using different settings of the the expression levels
of these factors to simulate different conditions.

The language defined here is designed to enable succinct and flexible
specification of such biological processes and experimental procedures
\otherlang{in silico} that result in a simulated expression matrix,
and also to specify a distance measure to compare the simulated matrix
to an \newterm{target matrix} comprised of expression data that is
externally provided (i.e.\ not generated by way of simulation). The
target matrix is also called the \newterm{empirical matrix}. In
addition to this specification, a transsys program, called the
\newterm{candidate program}, that models the regulatory network is
required to carry out the simulation. Candidate programs must satisfy
certain criteria in order to be suitable for simulation according to a
specification. Specifically, the transsys program needs to have
factors and genes that are specified by name in the simulation
protocol specification. Within these requirements, candidate programs
can be freely chosen.

\todo{we should not use synonyms and decide on whether to use
  expression set / expression matrix, target matrix / empirical
  matrix, \ldots}


\section{Objective Function Specification}

\subsection{Language Structure}

\subsubsection{The Top Level}

\begin{ebnfrule}
objectivespec ::= knockout_treatment_magic knockout_treatment_objectivespec
\end{ebnfrule}
The \computercode{knockout\_treatment\_magic} is a string that
identifies the file as an objective function specification. The
\computercode{knockout\_treatment\_objectivespec} contains the
objective function specification.

\begin{ebnfrule}
simgenex_def ::= procedure_defs simexpression_def expressionset_def discriminationsettings_def
\end{ebnfrule}
An objective function specification is comprised of a set of global
settings, a gene mapping, procedures, definitions of simulated gene
expression samples, and finally specifications of how simulations of
the empirical data, called \newterm{arrays}, are computed from the
simulated gene expression samples.


\subsubsection{Global Settings}

\todo{the name ``global settings'' is rather unspecific, this is due
  to the fact that the settings in here are quite heterogeneous and
  not really a modular unit.}

\begin{ebnfrule}
globalsettings ::= globalsettings_header globalsettings_body globalsettings_footer
NEWLINE
globalsettings_header ::= "globasettingdefs" NEWLINE
globalsettings_body ::= transformation_def distancemeasure_def offset_def
globalsettings_footer ::= "endglobalsettingdefs" NEWLINE

transformation_def ::= "transformation:" transformation_type NEWLINE
transformation_type ::= "log" | "none"

distancemeasure_def ::= "distance:" distance_type NEWLINE
distance_type ::= "correlation" | "euclidean" | "sum_squares" 

offset_def ::= "offset:" realnumber
\end{ebnfrule}

\todo{the order of applying offsets and log transformation matters,
  and this order bears no relation to the order specified for the
  language. The language spec should be updated; the offset and
  transformation specs should perhaps go into the array block (see
  comment below).}

The \computercode{globalsettings} contain the parameteters
\begin{itemize}
\item \computercode{transformation} sets the transformation of the
  expression levels. The \computercode{log} transformation applies the
  $\log_2$ function to expression values. \todo{verify: is it the log
    to base 2, or another log?. AVC. It's log2}
\item \computercode{distance} selects the method for computing
  distances between expression profiles.
\item \computercode{offset} specifies an offset to be added to
  expression levels. The offset can either be specified as an absolute
  value, or as a multiple of the standard deviation of the set of all
  expression levels. \todo{confirm that this precisely defines the
    implementation of the standard deviation variant. AVC. Yes It does}
\end{itemize}

\begin{ebnfrule}
genemapping_def ::= genemapping_header genemapping_body genemapping_footer NEWLINE
genemapping_header ::= "genemapping" NEWLINE
genemapping_body ::= (factor_def NEWLINE)+   
genemapping_footer ::= "endgenemapping" NEWLINE 
factor_def ::= "factor" identifier "=" (gene_manufacturer_identifier)+ NEWLINE
\end{ebnfrule}
The gene mapping maps transsys factor names (notice: not gene names)
to identifiers that label the profiles in the empirical matrix, (the
so-called gene manfacturer identifiers \todo{not really a fortunate
  term. AVC. Can we not use a more generic name is case PCR or other
  technologies are use to measure gene expression. ie.
  other\_identifier}).

The identifiers of the right hand side must be names of factors in the
candidate program.

No factor may be mapped more than once.

If there are multiple profiles in the empirical matrix that correspond to
one factor, these may be specified as a whitespace separated list. In
this case, the average profile is used for comparison.


\subsubsection{Procedures}
\label{section_procedures}

\todo{is it necessary that at least one procedure is required?}

\begin{ebnfrule}
procedure_defs ::= (procedure_def)+
procedure_def ::= procedure_header procedure_body procedure_footer NEWLINE

procedure_header ::= "procedure" identifier NEWLINE 
procedure_body ::= (instruction)+

instruction ::= procedure_identifier
        | primary_instruction

primary_instruction ::= "knockout:" identifier NEWLINE
        | "runtimesteps:" integer NEWLINE
        | "treatment:" identifier "=" realnumber NEWLINE
        | "overexpress:" identifier "=" realnumber NEWLINE
        | "setproduct:" identifier identifier NEWLINE
        | "foreach:" (identifier)+

procedure_footer ::= "\}"
procedure_identifier ::= identifier ";"
\end{ebnfrule}
A procedure specifies a sequence of operations to be performed on a
transsys instance. Operations are specified either by primary
instructions or by other procedures. Primary instructions specify
elementary operations that the simulator knows to perform. These are:
\begin{itemize}
\item \computercode{runtimesteps} runs the specified number of time
  steps to create a new transsys instance.
\item \computercode{knockout} removes the specified gene from the
  transsys program. The identifier must be the name of a gene in the
  candidate program. \todo{is it possible to ``knock a gene back
    in''?}. The knockout affects gene expression simulation (via the
  \computercode{runtimesteps} instruction) issued subsequently to the
  \computercode{knockout} instruction. Notice that the
  \computercode{knockout} operation modifies the candidate program.
\item \computercode{treatment} takes the name of a factor and a value
  that the expression level of the factor is to be set to. This
  operation is applied to the current transsys instance, overwriting
  the previous expression level of the factor. Subsequently, the
  expression dynamics of the factor will be determined by the
  candidate program.
\item \computercode{overexpress} inserts a new gene into the candidate
  program. The identifier is the name of an existing gene in the
  candidate program. The new gene encodes the same product as the
  specified existing gene, and has a promoter comprised of one
  \computercode{constitutive} element, expressing the gene at the
  specified rate.
\item \computercode{setproduct} replaces the product of the gene
  identified by the first identifier with the factor identified by the
  second identifier.
\item \computercode{foreach} expects a list of procedures. A
  \computercode{simexpression} containing a \computercode{foreach}
  statement results in multiple expression simulations. Each simulation
  is defined by the body of the \computercode{simexpression} element
  with the \computercode{foreach} statement replaced by the call to
  one of the procedures in the list. If a \computercode{simexpression}
  element contains multiple \computercode{foreach} statements, this
  replacement is carried out recursively so that all possible
  combinations of procedure calls are generated.
\end{itemize}
An identifier in a procedure body identifies another procedure to be
invoked. Invoking another procedure results in execution of the
instruction in the other procedure's body. By recursively applying
this rule, a procedure ultimately reduces to a sequence of primary
instructions.  It is an error for a procedure to refer to itself, or
to any procedure that eventually invokes itself, as infinite recursion
would occur in this case. \todo{is this ensured and is there a unit
  test for this?}

It is an error if an identifier does not reference an existing
procedure. Procedures may be listed in any order, so it is legal to
reference a procedure before it is defined.


\subsubsection{Gene Expression Sample Simulation}

\begin{ebnfrule}
simexpression_defs ::= (simexpression_def)+
Gsimexpression_def ::= simexpression_header simexpression_body simexpression_footer 
NEWLINE
simexpression_header ::= "simexpression" identifier NEWLINE
simexpression_body ::= (identifier NEWLINE)+
simexpression_footer ::= "endsimexpression" NEWLINE
\end{ebnfrule}

\todo{is there a reason to only allow procedures in the simexpression
  body? I think that simexpressions should also be allowed to contain
  primary instructions. This would mean that the bodies of procedures
  and simexpressions are specified in the same way (i.e.\ by the same
  rule). This would also make sense from an object oriented angle, as
  indeed a simexpression \emph{is a} (subclass of a) procedure, with
  the added feature that it results in the simulation of a column in
  the empirical matrix.}

\todo{On further pursuing this line of thought, it seems to me that
  the introduction of arrays has, from a formal / minimalist
  perspective, made simexpressions obsolete: Arrays could also be
  expressed in terms of procedures. It may however be worthwhile from
  the semantic perspective of distinguishing between procedures as
  partial instruction sequences that are to be used as building
  blocks, and simexpressions as complete sequences that model the life
  of a biological object.}

Simulations of gene expression, or ``simexpressions'' for short,
describe a simulation procedure to produce a transsys instance. The
idea is that the simulation procedure models the genetic makeup and
the relevant conditions and (possibly) experimental manipulations
experienced by a biological object. If the candidate program is a good
model of the gene regulatory network in the biological object, the
expression levels in the transsys instance are expected to be similar
to those measured in the biological object.

The sequence of identifiers in the body of a simexpression is resolved
to a sequence of primary instructions, as described for procedures in
section \ref{section_procedures}. The sequence of primary operations
is applied to a transsys instance of the unmodified candidate program,
with all expression levels starting at $0$. (Note: Future extensions
may provide mechanisms for specifying the initial state of the instance.)

Identifiers in a simexpression body must identify
procedures. Invocation of other simexpressions is an error.


\subsubsection{Arrays}

\begin{ebnfrule}
arraymapping_def ::= arraymapping_header arraymapping_body arraymapping_footer
arraymapping_header ::= "arraymapping" NEWLINE
arraymapping_body ::= (arraymapping_spec)+
# identifier following "array" identifies an array in the empirical data set
# identifier following ":" identifies a simexpression
# identifier following "/" identifies a simexpression to be used as a ratio reference
arraymapping_spec ::= "array" identifier ":" identifier ( "/" identifier)? NEWLINE
arraymapping_footer ::= "endarraymapping" NEWLINE
\end{ebnfrule}

\todo{It seems to me that it was not ideal to call these things
  arrays, because (1) gene expression can be measured by techniques
  other than microarrays and (2) arrays really correspond to
  simexpressions (perhaps with experimental noise added) -- one would
  say that e.g.\ logratios are computed based on the measurements of
  an array and the measurements of a reference array. Arrays should
  rather be called expression matrix columns -- is that a good or at
  least reasonable name?}

Arrays are columns in the simulated expression matrix. They are
computed by subjecting the expression levels in one or more
simexpressions to mathematical operations, resulting in a column
containing one value for each mapped factor of the candidate program.
The idea is that the mathematical operations should be the same as
those applied to the raw empirical data that have resulted in the
empirical expression matrix.

At this time, the only operations are copying a simexpression or
computing the element-wise ratio of two simexpressions. The latter
serves to realise logratios.

Array mapping operations are applied to values that have already been
subjected to offset adding and log transformation.

\todo{Consider consolidating the language by offset and logratio
  transformations into the arraymapping block? This would leave only
  the distance function specification in the globalsettings, which
  would be a step closer to separating the specification of the
  simulation from that of the distance measure.}
\cite{Parkinson2009}

\subsection{WhiteList}

\begin{ebnfrule}
whitelist_def ::= whitelist_header whitelist_body whitelist_footer
NEWLINE
whitelist_header ::= "whitelistdefs" NEWLINE
whitelist_body ::= whitelist_factor_def whitelist_gene_def
whitelist_footer ::= "endwhitelistdefs" NEWLINE
whitelist_factor_def ::= "factor" ":" (identifier)+
whitelist_gene_def ::= "gene: " (identifier)+ 
\end{ebnfrule}

WhiteList terms are those factors or genes, in a transsys program, whose
initial conditions must not be changed by the optimiser when performing
model selection. There are a number of reasons why this option is available, 
one of them is the use of mathematical expressions rather than single values
to specify under which conditions a biochemical reaction might take place.

\subsection{Terminal Tokens (Lexical Structure)}

\begin{ebnfrule}
----- terminals --------------------------------------------------------------------

knockout_treatment_magic ::= "KnockoutTreatmentObjectiveSpecification-0.1" NEWLINE
NEWLINE

gene_manufacturer_identifier ::= doublequote character_but_not_doublequote+ doublequote

realnumber ::= digit_sequence "." unsigned_digit_sequence+ scale_factor+
                | digit_sequence scale_factor

digit_sequence ::= sign+ unsigned_digit_sequence

unsigned_digit_sequence ::= digit+


scale_factor ::= ("E" | "e") digit_sequence
sign ::=  "+" | "-"


digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

identifier ::= (letter | "_") (letter | digit | "_")+

letter ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K"| "L" 
| "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W"| "X" | "Y" 
| "Z"| "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k"| "l" 
| "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

doublequote ::= the doublequote character (chr(34))
\end{ebnfrule}
\bibliographystyle{plain}
\bibliography{bioinfo}


\section{Future Perspectives}

\subsection{Optimisation by Reusing Prefix Instruction Sequences}

Simexpressions reduce to sequences of primary instructions. If two
simexpressions share a prefix (i.e.\ they start with the same sequence
of instructions) and the candidate program is deterministic (i.e.\ it
does not use any of the random number generation functions provided by
transsys), the two simexpressions that share a prefix sequence can be
computed by first computing the prefix sequence and then using that as
a starting point for computing both the first and the second
simexpression. Depending on the execution time of the prefix, this can
be a significant optimisation (e.g.\ where many time steps are used
for equilibration of a transsys instance).

As a special case, one simexpression may be a prefix of another.
When a set of simexpressions simulates a time series, they will form
nested prefixes.

To fully exploit the optimisation potential especially for time series
as described above, an optimiser must be able to break up a
\computercode{runtimesteps} $t$ instruction into commands
\computercode{runtimesteps} $n_1$ and \computercode{runtimesteps}
$n_2$, where $n_1 + n_2 = n$, as appropriate.

It is important to notice that the validity of this optimisation
depends on the assumption that the candidate program is
deterministic. This may not hold, therefore simulating all
simexpressions independently must be retained.

If the transsys program object provided a method to detect whether
the program is deterministic, simulators could use that method to
automatically activate the prefix optimisation as appropriate.


\subsection{SimGenex 2.0}

Syntactic features:

\begin{itemize}
\item Blocks should be in curly braces rather than in
  \computercode{something} \ldots \computercode{endsomething}.
\item Statements should be delimited by \computercode{;} so that
  newlines are not necessary or considered as terminators or
  separators.
\item \computercode{simexpression} blocks are really procedures, so
  they are replaced with procedures.
\item review keywords
\end{itemize}

EBNF of SimGenex 2.0, without the individual transformation:

\begin{ebnfrule}
expressionset_def ::= "expressionset" "\{" genemapping_def measurementprocess_def measurements_def "\}"
genemapping_def ::= "\{" (factor_def)+ "\}"
factor_def ::= "factor" identifier "=" (gene_manufacturer_identifier)+ ";"
measurementprocess_def ::= "measurementprocess" "\{" offset_def transformation_def "\}"
offset_def ::= "offset:" realnumber ";"
        | "offset:" realnumber * expressionstat ";"
expressionstat ::= "negmin()" | "stddev()"
transformation ::= "transformation:" transformation_expr ";"
transformation_expr ::= transformation_expr "+" transformation_term
        | transformation_expr "-" transformation_term
        | transformation_term
transformation_term ::= transformation_term "+" transformation_unary
        | transformation_term "-" transformation_unary
        | transformation_unary
transformation_unary ::= "log2(" transformation_expression ")"
        | "offset(" transformation_expression ")"
        | identifier
measurements_def ::=  "measurements" "\{" measurement_def "\}"
measurement_def ::= identifier ":" mvar_assignment_list ";"
mvar_assignment_list ::= mvar_assignment_list "," mvar_assignment
        | mvar_assignment
mvar_assignment ::= identifier "=" identifier
discriminationsettings_def ::= "\{"  distance_def whitelist_def "\}"
\end{ebnfrule}

\subsubsection{Example SimGenex 2.0 Code}

\begin{footnotesize}
\begin{verbatim}
SimGenex-2.0


procedure equilibration
{
  runtimesteps: 300;
}

procedure timepoint015min
{
  runtimesteps: 3;
}

procedure timepoint030min
{
  runtimesteps: 6;
}

procedure ko_g0
{
  knockout: g0;
}

procedure f1_treatment
{
  treatment: f1 = 1.0;
}

procedure overexpressgene
{
  overexpress: g1 = 0.7;
}

simexpression wt
{
  equilibration;
}

simexpression wt_treatment15
{
  equilibration;
  f01_treatment;
  timepoint015min;
}

simexpression wt_treatment30
{
  equilibration;
  f01_treatment;
  timepoint030min;
}

simexpression g0
{
  ko_g0;
  equilibration;
}

simexpression g0_treatment15
{
  ko_g0;
  overexpressgene;
  equilibration;
  f01_treatment;
  timepoint015min;
}

simexpression g0_treatment30
{
  ko_g0;
  equilibration;
  f01_treatment;
  timepoint030min;
}

expressionset
{
  genemapping
  {
    factor f0 = "257221_at" "257222_at" "257223_at";
    factor f1 = "257224_at";
  }

  measurementprocess
  {
    # offset: 1 * negmin();
    offset: 1e-3 * stddev();
    transformation: log(offset(x1)) / log(offset(x2));
  }

  measurements
  {
    wt_treatment15 : x1 = wt_treatment15, x2 = wt;
    wt_treatment30 : x1 = wt_treatment30, x2 = wt;
    g0000_treatment15 : x1 = g0_treatment15, x2 = g0;
    g0000_treatment30 : x1 = g0_treatment30, x2 = g0;
    wt : transformation log(wt) / log(wt);
  }
}

discriminationsettings
{
  distance: correlation;
  whitelistdefs
  {
    factor: f0 f1
    gene: g0
  }
}
\end{verbatim}
\end{footnotesize}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
